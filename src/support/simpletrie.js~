class TrieNode {
    constructor(k){
	this.key = k
	this.children = {}
    }
    //assumes direct discendant 
    addChild(node){
	this.children[node.key] = node
    }

}

class SimpleTrie {
    constructor(){
	this.root = new TrieNode('')
	this.nodeCount = 0
    }

    addString(string) {
	let arrChars = string.split('')
	this.insert(arrChars)
    }

    //Insert into the trie a string based on its character array
    insert(arrChars) {
	let start = this.root
	arrChars.reduce( (loc,symb) => {
	    loc.children[symb] = loc.children[symb] || new TrieNode(symb)
	    return loc.children[symb]
	},start)
    }

    //Test for the existance of a string
    //Assumes empty string is always present
    exists(string) {
	let rez = descend(string)
	if(rez)
	    return true
	else
	    return false
    }

    descend (prefix) {
	let curNode = this.root
	let ix = 0
	let len = prefix.length
	let node = null
	while (curNode && ix < length){
	    if(curNode.children[string[ix]]){
		curNode = string.children[string[ix]]
		ix++
	    }
	    else
		return null
	}
	return curNode
    }

    accumulateStrings(prefix,node,currDepth,maxDepth,flags){
	let results = []
	if(currDepth === (maxDepth))
	{
	    return [prefix + node.key]
	}
	else
	{
	    results = Object.keys(node.children).reduce((list,key)=>{
		return list.concat(accumulateStrings(prefix+key,
						     node.children[key],
						     currDepth+1,
						     maxDepth,
						     flags))
	    },[])
	}
	results.push(prefix + node.key)
	return results
    }
    
    gatherResults(prefix,node,depth,flags){
	return accumulateStrings(prefix,node,0,depth,flags)
    }
    
    query(prefix,depth,exact) {
	let node = descend(prefix)
	let flags = null
	if(depth === 0)
	    return [node.key]
	return gatherResults(prefix,node,depth,flags)
    }

    
}
export SimpleTrie
